<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Secret Between Us</title>

  <link rel="icon" type="image/x-icon" href="https://i.pinimg.com/564x/47/60/f2/4760f2a5f2ec15949d39871857a3c174.jpg">
    <link href="https://fonts.googleapis.com/css2?family=SF+Pro+Display:wght@300;400;500&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f7;
            color: #1d1d1f;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            padding: 30px;
            border-radius: 18px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        h1 {
            text-align: center;
            color: #1d1d1f;
            margin-bottom: 30px;
            font-size: calc(1.5rem + 2vw);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        textarea, input[type="text"], input[type="number"] {
            width: 100%;
            margin-bottom: 20px;
            border: 1px solid #d2d2d7;
            border-radius: 8px;
            font-size: 16px;
        }
        button {
            display: block;
            width: 100%;
            padding: 10px;
            background-color: #000000;
            color: rgb(255, 255, 255);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            margin-bottom: 20px;
        }
        button:hover {
            background-color: #000000;
            color: white;
        }
        .output {
            background-color: #f5f5f7;
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
        }
        .tab-container {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
        }
        .tab {
            color:#1d1d1f;
            font-weight: bold;
            padding: 10px 15px;
            cursor: pointer;
            background: #f5f5f7;
            border: none;
            border-radius: 8px;
            margin: 0 5px;
        }
        .tab.active {
            background-color: #000000;
            color: white;
        }
        .section {
            display: none;
        }
        .section.active {
            display: block;
        }
        .toggle-switch {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
        }
        .toggle-switch input {
            margin-right: 10px;
        }
        #downloadButton {
            display: none;
            margin-top: 20px;
        }
        
        .bst{
font-size:4vw;
            font-weight: bolder;
            padding: 20px;
        }
        /* Mobile styles */
        @media (max-width: 768px) {
            h1 {
                font-size: 5vw;
            }
            .container {
                padding: 15px;
            }
            .tab-container {
                display: none;
            }
            .dropdown {
                position: relative;
                display: inline-block;
                width: 100%;
                margin-bottom: 20px;
            }
            .dropbtn {
                background-color: #000000;
                color: white;
                padding: 12px;
                font-size: 16px;
                border: none;
                cursor: pointer;
                width: 100%;
                text-align: left;
                border-radius: 8px;
            }
            .dropdown-content {
                display: none;
                position: absolute;
                background-color: #f9f9f9;
                min-width: 160px;
                box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
                z-index: 1;
                width: 100%;
                border-radius: 8px;
            }
            .dropdown-content a {
                color: black;
                padding: 12px 16px;
                text-decoration: none;
                display: block;
            }
            .dropdown-content a:hover {
                background-color: #f1f1f1;
            }
            .show {
                display: block;
            }
        }
        
        /* Desktop styles */
        @media (min-width: 769px) {
            .container {
                padding: 40px;
            }
            .tab-container {
                flex-wrap: nowrap;
            }
            .tab {
                font-size: 16px;
            }
            .dropdown {
                display: none;
            }
        }

        /* The switch - the box around the slider */
        .switch {
          font-size: 17px;
          position: relative;
          display: inline-block;
          width: 3.5em;
          height: 2em;
        }

        /* Hide default HTML checkbox */
        .switch input {
          opacity: 0;
          width: 0;
          height: 0;
        }

        /* The slider */
        .slider {
          position: absolute;
          cursor: pointer;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background-color: rgb(182, 182, 182);
          transition: .4s;
          border-radius: 10px;
        }

        .slider:before {
          position: absolute;
          content: "";
          height: 1.4em;
          width: 1.4em;
          border-radius: 8px;
          left: 0.3em;
          bottom: 0.3em;
          transform: rotate(270deg);
          background-color: rgb(255, 255, 255);
          transition: .4s;
        }

        .switch input:checked + .slider {
          background-color: #21cc4c;
        }

        .switch input:focus + .slider {
          box-shadow: 0 0 1px #2196F3;
        }

        .switch input:checked + .slider:before {
          transform: translateX(1.5em);
        }
         .toggle-section {
            border: 1px solid #d2d2d7;
            border-radius: 12px;
            margin-bottom: 20px;
        }
        .toggle-header {
            background-color: #f5f5f7;
            padding: 15px;
            cursor: pointer;
            font-weight: 600;
        }
        .toggle-content {
            display: none;
            padding: 20px;
        }
        .active .toggle-content {
            display: block;
        }
        .con1{
            margin-top: 20px;
        }
        #debughi { margin-top: 20px; font-family: monospace; white-space: pre-wrap; }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸ–¤ Secrets Between Us ðŸ–¤</h1>
        <div class="tab-container">
            <button class="tab active" data-target="morse">Morse Code</button>
            <button class="tab" data-target="caesar">Caesar Cipher</button>
            <button class="tab" data-target="vigenere">VigenÃ¨re Cipher</button>
            <button class="tab" data-target="binary">Binary</button>
            <button class="tab" data-target="base64">Base64</button>
            <button class="tab" data-target="unicode">Secret Unicode</button>
            <button class="tab" data-target="stego">Text in Image</button>
        </div>
        
        <div class="dropdown">
            <button onclick="toggleDropdown()" class="dropbtn">Select Cipher â–¼</button>
            <div id="myDropdown" class="dropdown-content">
                <a href="#" data-target="morse">Morse Code</a>
                <a href="#" data-target="caesar">Caesar Cipher</a>
                <a href="#" data-target="vigenere">VigenÃ¨re Cipher</a>
                <a href="#" data-target="binary">Binary</a>
                <a href="#" data-target="base64">Base64</a>
                <a href="#" data-target="unicode">Secret Unicode</a>
                <a href="#" data-target="stego">Text in Image</a>
            </div>
        </div>
        <div id="morseSection" class="section active">
    <textarea id="morseInput" rows="5" placeholder="Enter text or Morse code here..."></textarea>
    <button onclick="translateMorse()">Convert Morse</button>
    <div id="morseOutput" class="output"></div>
    
</div>

<div id="caesarSection" class="section">
    <div class="toggle-switch">
        <label class="switch">
            <input type="checkbox" id="caesarToggle">
            <span class="slider"></span>
        </label>
        <span class="bst">Decrypt</span>
    </div>
    <input type="number" id="caesarShift" placeholder="Shift" min="0" max="25" value="3">
    <textarea id="caesarInput" rows="5" placeholder="Enter text here..."></textarea>
    <button onclick="processCaesar()">Process Caesar</button>
    <div id="caesarOutput" class="output"></div>
</div>

<div id="vigenereSection" class="section">
    <div class="toggle-switch">
        <label class="switch">
            <input type="checkbox" id="vigenereToggle">
            <span class="slider"></span>
        </label>
        <span class="bst">Decrypt</span>
    </div>
    <input type="text" id="vigenereKey" placeholder="Enter key...">
    <textarea id="vigenereInput" rows="5" placeholder="Enter text..."></textarea>
    <button onclick="processVigenere()">Process VigenÃ¨re</button>
    <div id="vigenereOutput" class="output"></div>
</div>

<div id="binarySection" class="section">
    <div class="toggle-switch">
        <label class="switch">
            <input type="checkbox" id="binaryToggle">
            <span class="slider"></span>
        </label>
        <span class="bst">Binary to Text</span>
    </div>
    <textarea id="binaryInput" rows="5" placeholder="Enter text or binary..."></textarea>
    <button onclick="processBinary()">Convert Binary</button>
    <div id="binaryOutput" class="output"></div>
</div>

<div id="base64Section" class="section">
    <div class="toggle-switch">
        <label class="switch">
            <input type="checkbox" id="base64Toggle">
            <span class="slider"></span>
        </label>
        <span class="bst">Decode</span>
    </div>
    <textarea id="base64Input" rows="5" placeholder="Enter text..."></textarea>
    <button onclick="processBase64()">Process Base64</button>
    <div id="base64Output" class="output"></div>
</div>

<div id="stegoSection" class="section">
    <input type="file" id="imageInput" accept="image/*">
    <textarea id="stegoText" rows="3" placeholder="Enter secret text..."></textarea>
    <button onclick="hideTextInImage()">Hide Text in Image</button>
    <button onclick="extractTextFromImage()">Extract Secret from Image</button>
    <div id="stegoOutput" class="output"></div>
    <img id="stegoImage" src="" alt="Stego Image" style="display: none; max-width: 100%; margin-top: 20px;">
    <button id="downloadButton" onclick="downloadImage()" style="display: none;">Download Modified Image</button>
</div>

<div id="unicodeSection" class="section">
    <div class="toggle-section">
        <div class="toggle-header" onclick="toggleSection(this)">Secret Unicode</div>
        <div class="toggle-content">
            <h2>Original Text</h2>
            <textarea id="originalText" placeholder="Enter your text here"></textarea>
            
            <h2>Encrypted/Decrypted Text</h2>
            <textarea id="resultText" readonly></textarea>
            
            <button onclick="encrypt()">Encrypt</button>
            <button onclick="decrypt()">Decrypt</button>
            <button id="copyButton" onclick="copyToClipboard('resultText')">Copy</button>
        </div>
    </div>
</div>

<div class="con1">
    <div class="container">
        <h1>ðŸ‘» Daily conversation ðŸ‘»</h1>
        <textarea id="input" placeholder="Enter text to encrypt or decrypt"></textarea>
        <br>
        <button onclick="randencrypt()">Encrypt</button>
        <button onclick="randdecrypt()">Decrypt</button>
        <br><br>
        <textarea id="output" readonly></textarea>
        <button id="copyButton" onclick="copyToClipboard('output')">Copy</button>
        <div id="debug"></div>
    </div>
</div>
    <script>
        //copy to clipboard 
        function copyToClipboard(elementId) {
    const element = document.getElementById(elementId);
    element.select();
    element.setSelectionRange(0, 99999); // For mobile devices
    navigator.clipboard.writeText(element.value);
    alert('Text copied to clipboard!');
}
        const morseCode = {
            'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.',
            'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..',
            'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.',
            'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-',
            'Y': '-.--', 'Z': '--..', '0': '-----', '1': '.----', '2': '..---',
            '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...',
            '8': '---..', '9': '----.', '.': '.-.-.-', ',': '--..--', '?': '..--..',
            "'": '.----.', '!': '-.-.--', '/': '-..-.', '(': '-.--.', ')': '-.--.-',
            '&': '.-...', ':': '---...', ';': '-.-.-.', '=': '-...-', '+': '.-.-.',
            '-': '-....-', '_': '..--.-', '"': '.-..-.', '$': '...-..-', '@': '.--.-.',
            ' ': '/'
        };

        function translateMorse() {
            const input = document.getElementById('morseInput').value.trim().toUpperCase();
            const output = document.getElementById('morseOutput');
            
            if (input.includes('.') || input.includes('-')) {
                // Morse to Text
                const words = input.split('/');
                const translated = words.map(word => {
                    return word.trim().split(' ').map(char => {
                        return Object.keys(morseCode).find(key => morseCode[key] === char) || char;
                    }).join('');
                }).join(' ');
                output.textContent = translated;
            } else {
                // Text to Morse
                const translated = input.split('').map(char => {
                    return morseCode[char] || char;
                }).join(' ');
                output.textContent = translated;
            }
        }

        function caesarCipher(text, shift, decrypt = false) {
            return text.split('').map(char => {
                if (char.match(/[a-z]/i)) {
                    const code = char.charCodeAt(0);
                    let shiftAmount = (decrypt ? -shift : shift) % 26;
                    let shiftedCode = code + shiftAmount;
                    if (shiftedCode > (char === char.toUpperCase() ? 90 : 122)) {
                        shiftedCode -= 26;
                    } else if (shiftedCode < (char === char.toUpperCase() ? 65 : 97)) {
                        shiftedCode += 26;
                    }
                    return String.fromCharCode(shiftedCode);
                }
                return char;
            }).join('');
        }

        function processCaesar() {
            const input = document.getElementById('caesarInput').value;
            const shift = parseInt(document.getElementById('caesarShift').value);
            const isDecrypt = document.getElementById('caesarToggle').checked;
            const output = document.getElementById('caesarOutput');
            
            const result = caesarCipher(input, shift, isDecrypt);
            output.textContent = `Shift: ${shift} - ${result}`;
        }

        function vigenere(text, key, decrypt = false) {
            const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
            let result = '';
            let keyIndex = 0;

            for (let i = 0; i < text.length; i++) {
                const char = text[i].toUpperCase();
                if (alphabet.includes(char)) {
                    const charIndex = alphabet.indexOf(char);
                    const keyChar = key[keyIndex % key.length].toUpperCase();
                    const keyCharIndex = alphabet.indexOf(keyChar);
                    let newIndex;

                    if (decrypt) {
                        newIndex = (charIndex - keyCharIndex + 26) % 26;
                    } else {
                        newIndex = (charIndex + keyCharIndex) % 26;
                    }

                    result += text[i] === text[i].toUpperCase() ? alphabet[newIndex] : alphabet[newIndex].toLowerCase();
                    keyIndex++;
                } else {
                    result += text[i];
                }
            }

            return result;
        }

        function processVigenere() {
            const input = document.getElementById('vigenereInput').value;
            const key = document.getElementById('vigenereKey').value;
            const isDecrypt = document.getElementById('vigenereToggle').checked;
            const output = document.getElementById('vigenereOutput');
            
            if (!key) {
                output.textContent = "Please enter a key.";
                return;
            }

            const result = vigenere(input, key, isDecrypt);
            output.textContent = `Key: ${key} - ${result}`;
        }

        function processBinary() {
            const input = document.getElementById('binaryInput').value;
            const output = document.getElementById('binaryOutput');
            const isBinaryToText = document.getElementById('binaryToggle').checked;
            
            if (isBinaryToText) {
                // Binary to Text
                output.textContent = input.split(' ').map(bin => String.fromCharCode(parseInt(bin, 2))).join('');
            } else {
                // Text to Binary
                output.textContent = input.split('').map(char => char.charCodeAt(0).toString(2).padStart(8, '0')).join(' ');
            }
        }

        function processBase64() {
            const input = document.getElementById('base64Input').value;
            const output = document.getElementById('base64Output');
            const isDecode = document.getElementById('base64Toggle').checked;
            
            if (isDecode) {
                try {
                    output.textContent = atob(input);
                } catch (e) {
                    output.textContent = "Invalid Base64 input";
                }
            } else {
                output.textContent = btoa(input);
            }
        }

        function hideTextInImage() {
            const file = document.getElementById('imageInput').files[0];
            const text = document.getElementById('stegoText').value;
            
            if (!file || !text) {
                alert('Please select an image and enter text.');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(event) {
                const img = new Image();
                img.onload = function() {
                    const canvas = document.createElement('canvas');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0);

                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const encodedText = btoa(text);
                    
                    // Store the length of the encoded text in the first 4 pixels
                    const textLength = encodedText.length;
                    for (let i = 0; i < 4; i++) {
                        imageData.data[i * 4] = (textLength >> (i * 8)) & 255;
                    }
                    
                    for (let i = 0; i < encodedText.length; i++) {
                        const code = encodedText.charCodeAt(i);
                        imageData.data[(i + 4) * 4] = (imageData.data[(i + 4) * 4] & 0xFC) | ((code >> 6) & 0x3);
                        imageData.data[(i + 4) * 4 + 1] = (imageData.data[(i + 4) * 4 + 1] & 0xFC) | ((code >> 4) & 0x3);
                        imageData.data[(i + 4) * 4 + 2] = (imageData.data[(i + 4) * 4 + 2] & 0xFC) | ((code >> 2) & 0x3);
                        imageData.data[(i + 4) * 4 + 3] = (imageData.data[(i + 4) * 4 + 3] & 0xFC) | (code & 0x3);
                    }

                    ctx.putImageData(imageData, 0, 0);
                    document.getElementById('stegoImage').src = canvas.toDataURL();
                    document.getElementById('stegoImage').style.display = 'block';
                    document.getElementById('stegoOutput').textContent = 'Text hidden in image. You can now download the modified image.';
                    document.getElementById('downloadButton').style.display = 'block';
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        }

        function extractTextFromImage() {
            const file = document.getElementById('imageInput').files[0];
            
            if (!file) {
                alert('Please select an image.');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(event) {
                const img = new Image();
                img.onload = function() {
                    const canvas = document.createElement('canvas');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0);

                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    
                    // Extract the length of the encoded text from the first 4 pixels
                    let textLength = 0;
                    for (let i = 0; i < 4; i++) {
                        textLength |= (imageData.data[i * 4] << (i * 8));
                    }
                    
                    let extractedText = '';
                    for (let i = 0; i < textLength; i++) {
                        const byte = ((imageData.data[(i + 4) * 4] & 0x3) << 6) | 
                                     ((imageData.data[(i + 4) * 4 + 1] & 0x3) << 4) | 
                                     ((imageData.data[(i + 4) * 4 + 2] & 0x3) << 2) | 
                                     (imageData.data[(i + 4) * 4 + 3] & 0x3);
                        extractedText += String.fromCharCode(byte);
                    }

                    try {
                        const decodedText = atob(extractedText);
                        document.getElementById('stegoOutput').textContent = 'Extracted text: ' + decodedText;
                    } catch (e) {
                        document.getElementById('stegoOutput').textContent = 'No hidden text found or invalid encoding.';
                    }
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        }

        function downloadImage() {
            const image = document.getElementById('stegoImage');
            const link = document.createElement('a');
            link.href = image.src;
            link.download = 'stego_image.png';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // Tab functionality
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', function() {
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
                this.classList.add('active');
                document.getElementById(this.dataset.target + 'Section').classList.add('active');
            });
        });

        // Dropdown functionality
        function toggleDropdown() {
            document.getElementById("myDropdown").classList.toggle("show");
        }

        window.onclick = function(event) {
            if (!event.target.matches('.dropbtn')) {
                var dropdowns = document.getElementsByClassName("dropdown-content");
                for (var i = 0; i < dropdowns.length; i++) {
                    var openDropdown = dropdowns[i];
                    if (openDropdown.classList.contains('show')) {
                        openDropdown.classList.remove('show');
                    }
                }
            }
        }

        document.querySelectorAll('.dropdown-content a').forEach(item => {
            item.addEventListener('click', function(e) {
                e.preventDefault();
                document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
                document.getElementById(this.dataset.target + 'Section').classList.add('active');
                document.querySelector('.dropbtn').textContent = this.textContent + ' â–¼';
                document.getElementById("myDropdown").classList.remove("show");
            });
        });

        // // // Function to adjust h1 font size
        // // function adjustH1FontSize() {
        // //     const h1 = document.querySelector('h1');
        // //     const container = document.querySelector('.container');
        // //     let fontSize = 5;
        // //     h1.style.fontSize = fontSize + 'vw';

        // //     while (h1.scrollWidth > container.clientWidth || h1.scrollHeight > h1.clientHeight) {
        // //         fontSize -= 0.5;
        // //         h1.style.fontSize = fontSize + 'vw';
        // //         if (fontSize <= 1) break; // Prevent infinite loop
        // //     }
        // // }

        // // Call the function on load and resize
        // window.addEventListener('load', adjustH1FontSize);
        // window.addEventListener('resize', adjustH1FontSize);
        
        // New functions for Secret Unicode
        const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()_+-=[]{}|;:,.<>?/ ';
        
        const unicodeRanges = [
            [0x0370, 0x03FF],  // Greek and Coptic
            [0x0400, 0x04FF],  // Cyrillic
            [0x0500, 0x052F],  // Cyrillic Supplement
            [0x0530, 0x058F],  // Armenian
            [0x0590, 0x05FF],  // Hebrew
            [0x0600, 0x06FF],  // Arabic
            [0x0700, 0x074F],  // Syriac
            [0x0750, 0x077F],  // Arabic Supplement
            [0x0780, 0x07BF],  // Thaana
            [0x0900, 0x097F],  // Devanagari
            [0x0980, 0x09FF],  // Bengali
            [0x0A00, 0x0A7F],  // Gurmukhi
            [0x0A80, 0x0AFF],  // Gujarati
            [0x0B00, 0x0B7F],  // Oriya
            [0x0B80, 0x0BFF],  // Tamil
            [0x0C00, 0x0C7F],  // Telugu
            [0x0C80, 0x0CFF],  // Kannada
            [0x0D00, 0x0D7F],  // Malayalam
            [0x0D80, 0x0DFF],  // Sinhala
            [0x0E00, 0x0E7F],  // Thai
            [0x0E80, 0x0EFF],  // Lao
            [0x0F00, 0x0FFF],  // Tibetan
            [0x1000, 0x109F],  // Myanmar
            [0x10A0, 0x10FF],  // Georgian
            [0x1100, 0x11FF],  // Hangul Jamo
            [0x1200, 0x137F],  // Ethiopic
            [0x13A0, 0x13FF],  // Cherokee
            [0x1400, 0x167F],  // Unified Canadian Aboriginal Syllabics
            [0x1680, 0x169F],  // Ogham
            [0x16A0, 0x16FF],  // Runic
            [0x1700, 0x171F],  // Tagalog
            [0x1720, 0x173F],  // Hanunoo
            [0x1740, 0x175F],  // Buhid
            [0x1760, 0x177F],  // Tagbanwa
            [0x1780, 0x17FF],  // Khmer
            [0x1800, 0x18AF],  // Mongolian
            [0x1900, 0x194F],  // Limbu
            [0x1950, 0x197F],  // Tai Le
            [0x1980, 0x19DF],  // New Tai Lue
            [0x19E0, 0x19FF],  // Khmer Symbols
            [0x1A00, 0x1A1F],  // Buginese
            [0x1B00, 0x1B7F],  // Balinese
            [0x1D00, 0x1D7F],  // Phonetic Extensions
            [0x1E00, 0x1EFF],  // Latin Extended Additional
            [0x1F00, 0x1FFF],  // Greek Extended
            [0x2C00, 0x2C5F],  // Glagolitic
            [0x2C60, 0x2C7F],  // Latin Extended-C
            [0x2C80, 0x2CFF],  // Coptic
            [0x2D00, 0x2D2F],  // Georgian Supplement
            [0x2D30, 0x2D7F],  // Tifinagh
            [0x2D80, 0x2DDF],  // Ethiopic Extended
            [0x2DE0, 0x2DFF],  // Cyrillic Extended-A
            [0x2E00, 0x2E7F],  // Supplemental Punctuation
            [0x2E80, 0x2EFF],  // CJK Radicals Supplement
            [0x2F00, 0x2FDF],  // Kangxi Radicals
            [0x2FF0, 0x2FFF],  // Ideographic Description Characters
            [0x3000, 0x303F],  // CJK Symbols and Punctuation
            [0x3040, 0x309F],  // Hiragana
            [0x30A0, 0x30FF],  // Katakana
            [0x3100, 0x312F],  // Bopomofo
            [0x3130, 0x318F],  // Hangul Compatibility Jamo
            [0x3190, 0x319F],  // Kanbun
            [0x31A0, 0x31BF],  // Bopomofo Extended
            [0x31C0, 0x31EF],  // CJK Strokes
            [0x31F0, 0x31FF],  // Katakana Phonetic Extensions
            [0x3200, 0x32FF],  // Enclosed CJK Letters and Months
            [0x3300, 0x33FF],  // CJK Compatibility
            [0x3400, 0x4DBF],  // CJK Unified Ideographs Extension A
            [0x4DC0, 0x4DFF],  // Yijing Hexagram Symbols
            [0x4E00, 0x9FFF],  // CJK Unified Ideographs
            [0xA000, 0xA48F],  // Yi Syllables
            [0xA490, 0xA4CF],  // Yi Radicals
            [0xAC00, 0xD7AF],  // Hangul Syllables
            [0xD800, 0xDB7F],  // High Surrogates
            [0xDB80, 0xDBFF],  // High Private Use Surrogates
            [0xDC00, 0xDFFF],  // Low Surrogates
            [0xE000, 0xF8FF],  // Private Use Area
            [0xF900, 0xFAFF],  // CJK Compatibility Ideographs
            [0xFB00, 0xFB4F],  // Alphabetic Presentation Forms
            [0xFB50, 0xFDFF],  // Arabic Presentation Forms-A
            [0xFE00, 0xFE0F],  // Variation Selectors
            [0xFE10, 0xFE1F],  // Vertical Forms
            [0xFE20, 0xFE2F],  // Combining Half Marks
            [0xFE30, 0xFE4F],  // CJK Compatibility Forms
            [0xFE50, 0xFE6F],  // Small Form Variants
            [0xFE70, 0xFEFF],  // Arabic Presentation Forms-B
            [0xFF00, 0xFFEF],  // Halfwidth and Fullwidth Forms
            [0xFFF0, 0xFFFF]   // Specials
        ];
       

        function toggleSection(element) {
            element.parentElement.classList.toggle('active');
        }

        function getRandomUnicodeChar() {
            const rangeIndex = Math.floor(Math.random() * unicodeRanges.length);
            const [start, end] = unicodeRanges[rangeIndex];
            return String.fromCharCode(Math.floor(Math.random() * (end - start + 1) + start));
        }

        function generateKey() {
            let key = '';
            for (let i = 0; i < characters.length; i++) {
                key += getRandomUnicodeChar();
            }
            return key;
        }
        function encrypt() {
    const original = document.getElementById('originalText').value;
    const key = generateKey();
    let encrypted = key + '\n';
    for (let char of original) {
        const index = characters.indexOf(char);
        if (index !== -1) {
            encrypted += key[index];
        } else {
            encrypted += char;
        }
    }
    document.getElementById('resultText').value = encrypted;
}
    
        
        function decrypt() {
    const encrypted = document.getElementById('originalText').value;
    console.log("Encrypted text:", encrypted);
    const lines = encrypted.split('\n');
    console.log("Lines:", lines);
    if (lines.length < 2) {
        alert('Invalid encrypted text');
        return;
    }
    const key = lines[0];
    console.log("Key:", key);
    const text = lines.slice(1).join('\n');
    console.log("Text to decrypt:", text);
    let decrypted = '';
    for (let char of text) {
        const index = key.indexOf(char);
        if (index !== -1) {
            decrypted += characters[index];
        } else {
            decrypted += char;
        }
    }
    console.log("Decrypted text:", decrypted);
    document.getElementById('resultText').value = decrypted;
}

//Daily conversation 
const words = [
    "Did", "you", "eat", "yet?", 
    "Let's", "go", "to", "a", "movie.", 
    "Not", "everything", "that", "shines", "is", "great.", 
    "Actions", "speak", "louder", "than", "words.", 
    "Time", "flies", "Hangout", "fast!"
];

        function debug(message) {
            document.getElementById('debug').textContent += message + '\n';
        }

        function randencrypt() {
            const input = document.getElementById('input').value;
            debug('Encrypting: ' + input);
            let encrypted = '';
            
            for (let i = 0; i < input.length; i++) {
                const charCode = input.charCodeAt(i);
                const shift = Math.floor(Math.random() * words.length);
                const shiftedCode = (charCode + shift) % 256;
                const firstIndex = Math.floor(shiftedCode / words.length);
                const secondIndex = shiftedCode % words.length;
                const thirdIndex = shift;
                encrypted += words[firstIndex] + ' ' + words[secondIndex] + ' ' + words[thirdIndex] + ' ';
                debug(`Char: ${input[i]}, CharCode: ${charCode}, Shift: ${shift}, ShiftedCode: ${shiftedCode}, Words: ${words[firstIndex]} ${words[secondIndex]} ${words[thirdIndex]}`);
            }
            
            document.getElementById('output').value = encrypted.trim();
            debug('Encrypted result: ' + encrypted.trim());
        }

        function randdecrypt() {
            const input = document.getElementById('input').value;
            debug('Decrypting: ' + input);
            const encryptedWords = input.split(' ');
            let decrypted = '';
            
            for (let i = 0; i < encryptedWords.length; i += 3) {
                const firstIndex = words.indexOf(encryptedWords[i]);
                const secondIndex = words.indexOf(encryptedWords[i + 1]);
                const shift = words.indexOf(encryptedWords[i + 2]);
                if (firstIndex === -1 || secondIndex === -1 || shift === -1) {
                    debug(`Error: Word not found in list: ${encryptedWords[i]} or ${encryptedWords[i + 1]} or ${encryptedWords[i + 2]}`);
                    return;
                }
                let charCode = (firstIndex * words.length + secondIndex - shift + 256) % 256;
                decrypted += String.fromCharCode(charCode);
                debug(`Words: ${encryptedWords[i]} ${encryptedWords[i + 1]} ${encryptedWords[i + 2]}, Shift: ${shift}, CharCode: ${charCode}, Char: ${String.fromCharCode(charCode)}`);
            }
            
            document.getElementById('output').value = decrypted;
            debug('Decrypted result: ' + decrypted);
        }
        
    </script>
</body>
</html>
